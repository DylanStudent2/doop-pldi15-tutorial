{"name":"Doop Framework 101","tagline":"Tutorial site for PLDI 2015","body":"## About\r\n[Doop](http://doop.program-analysis.org/) is a **declarative** framework for Static Analysis of Java programs, centered on a variety of **pointer analysis** algorithms. Doop provides a huge variety of analyses and also the surrounding scaffolding to run an analysis end-to-end (fact generation, processing, statistics, etc.).\r\n\r\nThe declarative nature of Doop stems from its use of **Datalog** (more specifically *LogiQL*, a Datalog dialect developed by [LogicBlox](http://www.logicblox.com/)) to specify an analysis.\r\n\r\nThe building blocks of Datalog programs come in the form of **predicates**. Our input facts (a.k.a. *EDB* logic) are represented as predicate values, e.g., `Person(\"John\")` or `Parent(\"John\", \"Johnny jr\")`.\r\n\r\nThen we have **rules** (a.k.a. *IDB* logic) to infer new information from facts already known to be true. This continues until no new information can be extracted. E.g.,\r\n```\r\nAncestor(x, y) <- Parent(x, y).\r\n```\r\n\r\nTo familiarize yourself with Datalog evaluation, you may want to try the [LogicBlox REPL tutorial] (https://developer.logicblox.com/content/docs4/tutorial/repl/section/split.html).\r\n\r\n### Doop + Datalog Setup\r\n\r\nPlease use engine version 3.10 for this tutorial and download+unpack the main tutorial file from the links at the top of the page. If you are following this tutorial off-line, the relevant files should exist in the\r\narchive you copied.\r\n\r\n```\r\n$ cd tutorial_root_folder\r\n$ source environment.sh\r\n```\r\n\r\n### Toy Example\r\nWe want to compute the ancestors for a set of people. Our rules (left-arrow notation) along with their type declarations (right-arrow notation) are in [ancestors.logic](https://raw.githubusercontent.com/plast-lab/doop-pldi15-tutorial/gh-pages/code/examples/ancestors/ancestors.logic). Our facts (a.k.a. delta logic) are in [facts.logic](https://raw.githubusercontent.com/plast-lab/doop-pldi15-tutorial/gh-pages/code/examples/ancestors/facts.logic). The `+` operator in front of the delta predicates denotes that we want to add facts to our database (we could also remove or update facts).\r\n\r\nWe invoke actions on our Datalog engine using `bloxbatch`.\r\n\r\n```\r\n$ bloxbatch -db DB -create -overwrite              # create our database\r\n$ bloxbatch -db DB -addBlock -file ancestor.logic  # load our rules\r\n$ bloxbatch -db DB -execute -file facts.logic      # load our facts\r\n$ bloxbatch -db DB -print ancestor                 # print computed results\r\npredicate: Ancestor(Person, Person)\r\n...\r\n/--- start of Ancestor facts ---\\\r\n  [1]john, [0]harry\r\n  [2]dave, [0]harry\r\n  [2]dave, [1]john\r\n\\---- end of Ancestor facts ----/\r\n```\r\n\r\nThe line `Person(x), Name(x:n) -> string(n).` states that a person (represented by an internal ID) can be constructed by providing a string in the `Name` predicate. This is known as *refmode*. This is also shown in the print output. For example, `[1]john` means that the string *\"john\"* is used to create a Person with the ID *1*.\r\n\r\n## Doop Examples\r\n\r\nNow let's focus on more meaningful examples using Doop directly. Doop is available at bitbucket as a [public repo](https://bitbucket.org/yanniss/doop).\r\n\r\nWe will use a running example, found in [Example.java](https://raw.githubusercontent.com/plast-lab/doop-pldi15-tutorial/gh-pages/code/examples/Example.java).\r\n\r\n```\r\n$ cd doop\r\n$ mkjar Example.java   # create Example.jar\r\n```\r\n\r\nWe will run a simple naive analysis (`-a naive` option) on the generated jar file (`-j Example.jar` option). This analysis has only a few basic rules but it's a good representative skeleton of actual analyses. Since Doop performs a **whole program analysis**, the library will be analyzed along with application code. With the option `--jre 1.7` we specify the desired version of the library. \r\n\r\n```\r\n./doop -a naive -j Example.jar --jre 1.7 --no-stats\r\n```\r\n\r\nAfter the analysis has run, we can gather results by issuing queries directly to the database.\r\n\r\n### Analysis structure\r\nInput facts are auto-generated by the framework (using [Soot](https://github.com/Sable/soot)) and the schema can be found\r\n* in `logic/facts/declarations.logic`\r\n* and in `logic/facts/flow-insensitivity-declarations.logic`.\r\n\r\nThe rules for our naive analysis can be found in `logic/analyses/naive/analysis.logic`.\r\n\r\nFor example, the following rule states that **when** we have a heap allocation of a `?heap` object that is assigned to variable `?var` inside a method deemed reachable by our analysis, **then** we can infer that the variable may point to this heap object.\r\n```\r\nVarPointsTo(?var, ?heap) <-\r\n  AssignHeapAllocation(?heap, ?var, ?inMethod),\r\n  Reachable(?inMethod).\r\n```\r\n\r\nFurthermore, **when** we have some kind of assignment (direct or indirect) from one variable to another, and we know that the source variable may point to some heap object, **then** the target variable may point to the same heap object.\r\n```\r\nVarPointsTo(?to, ?heap) <-\r\n  Assign(?to, ?from),\r\n  VarPointsTo(?from, ?heap).\r\n```\r\nNote here that this rule is **recursive**; previously known facts about the *VarPointTo* relation may lead to the inference of additional facts. Doop analysis rules are **mutually recursive** in complex ways.\r\n\r\n## Queries\r\n### Objects ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}
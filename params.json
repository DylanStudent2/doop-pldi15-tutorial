{"name":"Doop Framework 101","tagline":"Tutorial site for PLDI 2015","body":"### So what is Doop?\r\n[Doop](http://doop.program-analysis.org/) is a **declarative** framework for Static Pointer Analysis of Java programs. It provides a huge variety of analyses and also all the surrounding scaffolding to run an analysis end-to-end (fact generation, processing, statistics and metrics, etc).\r\n\r\nThe declarative nature of Doop stems form the fact that is uses **Datalog** (or more specifically *LogiQL*, a Datalog dialog developped by [LogicBlox](http://www.logicblox.com/)) to specify an analysis.\r\n\r\nThe building blocks come in the form of **predicates**. Our facts (a.k.a *EDB* logic) are represented as such. E.g. `Person(\"John\")` or `Parent(\"John\", \"Johnny jr\")`.\r\n\r\nThen we have **rules** (a.k.a *IDB* logic) to infer new information. When a set of things are known to be true then we can infer new things. This continues until no new information can be extracted.\r\n\r\n     Ancestor(x, y) <- Parent(x, y).\r\n\r\n### Setup\r\n```\r\n$ cd doop_root_folder\r\n$ source environment.sh\r\n$ cd doop\r\n```\r\n\r\n### Toy Example\r\nWe want to compute the ancestors for a set of people. We invoke actions on our Datalog engine using `bloxbatch`.\r\n\r\n````\r\n$ bloxbatch -db DB -create -overwrite               # create our database\r\n$ bloxbatch -db DB -addBlock -file ancestor.logic   # load our rules\r\n$ bloxbatch -db DB -execute -file facts.logic       # load our facts\r\n$ bloxbatch -db DB -print ancestor                  # print computed results\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}
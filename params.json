{"name":"Doop Framework 101","tagline":"Tutorial site for PLDI 2015","body":"## About\r\n[Doop](http://doop.program-analysis.org/) is a **declarative** framework for Static Analysis of Java programs, centered on a variety of **pointer analysis** algorithms. Doop provides a huge variety of analyses and also the surrounding scaffolding to run an analysis end-to-end (fact generation, processing, statistics, etc.).\r\n\r\nThe declarative nature of Doop stems from its use of **Datalog** (more specifically *LogiQL*, a Datalog dialect developed by [LogicBlox](http://www.logicblox.com/)) to specify an analysis.\r\n\r\nThe building blocks of Datalog programs come in the form of **predicates**. Our input facts (a.k.a. EDB logic) are represented as predicate values, e.g., `Person(\"John\")` or `Parent(\"John\", \"Johnny jr\")`.\r\n\r\nThen we have **rules** (a.k.a. IDB logic) to infer new information from facts already known to be true. This continues until no new information can be extracted. E.g.,\r\n```\r\nAncestor(x, y) <- Parent(x, y).\r\n```\r\n\r\nTo familiarize yourself with Datalog evaluation, you may want to try the [LogicBlox REPL tutorial] (https://developer.logicblox.com/content/docs4/tutorial/repl/section/split.html).\r\n\r\n## Doop + Datalog Setup\r\n\r\nDoop is available at bitbucket as a [public repo](https://bitbucket.org/yanniss/doop).\r\n\r\nPlease use LogicBlox engine version 3.10.X for this tutorial and download+unpack the main tutorial file from the links at the top of the page. Put the engine (or a symbolic link to it) under the directory `code`. Also, clone Doop under the same directory. If you are following this tutorial off-line, the relevant files should exist in the archive you copied.\r\n\r\nIssue the following command to setup the environment.\r\n\r\n```\r\n$ source code/environment.sh\r\n```\r\n\r\n## Toy Example\r\nWe want to compute the ancestors for a set of people. Our rules (left-arrow notation) along with their type declarations (right-arrow notation) are in [ancestors.logic](https://raw.githubusercontent.com/plast-lab/doop-pldi15-tutorial/master/code/examples/ancestors/ancestors.logic). Our facts (a.k.a. delta logic) are in [facts.logic](https://raw.githubusercontent.com/plast-lab/doop-pldi15-tutorial/master/code/examples/ancestors/facts.logic). The `+` operator in front of the delta predicates denotes that we want to add facts to our database (we could also remove or update facts).\r\n\r\nWe invoke actions on our Datalog engine using `bloxbatch`.\r\n\r\n```\r\n$ cd code/examples/ancestors\r\n$ bloxbatch -db DB -create -overwrite              # create our database\r\n$ bloxbatch -db DB -addBlock -file ancestors.logic # load our rules\r\n$ bloxbatch -db DB -execute -file facts.logic      # load our facts\r\n$ bloxbatch -db DB -print Ancestor                 # print computed results\r\npredicate: Ancestor(Person, Person)\r\n...\r\n/--- start of Ancestor facts ---\\\r\n  [1]john, [0]harry\r\n  [2]dave, [0]harry\r\n  [2]dave, [1]john\r\n\\---- end of Ancestor facts ----/\r\n```\r\n\r\nThe line `Person(x), Name(x:n) -> string(n).` states that a person (represented by an internal ID) can be constructed by providing a string in the `Name` predicate. This is known as *refmode*. This is also shown in the print output. For example, `[1]john` means that the string *\"john\"* is used to create a Person with the ID *1*.\r\n\r\n## Doop Examples\r\n\r\nNow let's focus on more meaningful examples using Doop directly. We will use a running example, found in [Example.java](https://raw.githubusercontent.com/plast-lab/doop-pldi15-tutorial/master/code/examples/Example.java).\r\n\r\n```\r\n$ cd ..\r\n$ mkjar Example.java   # create Example.jar\r\n$ cd ../doop\r\n```\r\n\r\nWe will run a simple naive analysis (`-a naive` option) on the generated jar file (`-j ../examples/Example.jar` option). This analysis has only a few basic rules but it's a good representative skeleton of actual analyses. Since Doop performs a **whole program analysis**, the library will be analyzed along with application code. With the option `--jre 1.7` we specify the desired version of the library. \r\n\r\n```\r\n./doop -a naive -j ../examples/Example.jar --jre 1.7 --no-stats\r\n```\r\n\r\nAfter the analysis has run, we can gather results by issuing queries directly to the database.\r\n\r\n### Analysis structure\r\nInput facts are auto-generated by the framework (using [Soot](https://github.com/Sable/soot)) and then imported to the database so our rules can process them. The input schema can be found\r\n* in `logic/facts/declarations.logic`\r\n* and in `logic/facts/flow-insensitivity-declarations.logic`.\r\n\r\nThe rules for our naive analysis can be found in `logic/analyses/naive/analysis.logic`.\r\n\r\nFor example, the following rule states that **when** we have a heap allocation of a `?heap` object that is assigned to variable `?var` inside a method deemed reachable by our analysis, **then** we can infer that the variable may point to this heap object.\r\n```\r\nVarPointsTo(?var, ?heap) <-\r\n  AssignHeapAllocation(?heap, ?var, ?inMethod),\r\n  Reachable(?inMethod).\r\n```\r\n\r\nFurthermore, **when** we have some kind of assignment (direct or indirect) from one variable to another, and we know that the source variable may point to some heap object, **then** the target variable may point to the same heap object.\r\n```\r\nVarPointsTo(?to, ?heap) <-\r\n  Assign(?to, ?from),\r\n  VarPointsTo(?from, ?heap).\r\n```\r\nNote here that this rule is **recursive**; previously known facts about the *VarPointTo* relation may lead to the inference of additional facts. Doop analysis rules are **mutually recursive** in complex ways.\r\n\r\n### Accessing the database\r\n\r\n#### Query #1\r\nOur first query is to ask for *VarPointTo* entries of variables declared in *Example.morePlay()*.\r\n\r\n```\r\n$ bloxbatch -db last-analysis -query \\\r\n'_(?var, ?heap) <- VarPointsTo(?var, ?heap), Var:DeclaringMethod(?var, \"<Example: void morePlay(Cat)>\").'\r\n  Example.morePlay/@this, Example.main/new Example/0\r\n  Example.morePlay/r0, Example.main/new Example/0\r\n  Example.morePlay/r3, Example.test/new Cat/1\r\n  Example.morePlay/r4, Example.test/new Cat/1\r\n  Example.morePlay/r1, Example.test/new Cat/1\r\n  Example.morePlay/@param0, Example.test/new Cat/1\r\n  Example.morePlay/r2, Example.test/new Cat/2\r\n  Example.morePlay/r3, Example.test/new Cat/2\r\n  Example.morePlay/r4, Example.test/new Cat/2\r\n```\r\n\r\nThe string provided to the `-query` flag can be a set of left and right arrow Datalog rules. Newly created predicates have to start with `_` since they will only exist for the duration of the query evaluation. Refmode values can be used directly, and the engine will automatically substitute them with their internal IDs. E.g., the following part\r\n```\r\nVar:DeclaringMethod(?var, \"<Example: void morePlay(Cat)>\")\r\n```\r\nis equivalent to\r\n```\r\nVar:DeclaringMethod(?var, ?method), MethodSignature:Value(?method:\"<Example: void morePlay(Cat)>\")\r\n```\r\n\r\nNote here that Doop analyzes Java **bytecode**. Input facts are generated using Soot, which transforms Java bytecode to [Jimple](http://en.wikipedia.org/wiki/Soot_%28software%29#Jimple), a language based on *three address code*. As a result new temp variables are introduced and also original variable names might be lost (they can be retained through specific flags in javac and Soot).\r\n\r\n***\r\n\r\n#### Query #2\r\nA more advanced query can be found in [query2.logic](https://raw.githubusercontent.com/plast-lab/doop-pldi15-tutorial/master/code/examples/query2.logic). Essentially, we compute a transitive closure on the *CallGraphEdge* relation. The logic used in a query can be as complicated as in any \"normal\" Datalog program.\r\n\r\n```\r\n$ bloxbatch -db last-analysis -query -file ../examples/query2.logic\r\n  <Example: void main(java.lang.String[])>, <Example: void test(int)>\r\n  <Example: void test(int)>, <Example: void morePlay(Cat)>\r\n  <Example: void main(java.lang.String[])>, <Example: void morePlay(Cat)>\r\n  <Example: void test(int)>, <Cat: void setParent(Cat)>\r\n  <Example: void main(java.lang.String[])>, <Cat: void setParent(Cat)>\r\n  <Example: void test(int)>, <Cat: Cat getParent()>\r\n  <Example: void morePlay(Cat)>, <Cat: Cat getParent()>\r\n  <Example: void main(java.lang.String[])>, <Cat: Cat getParent()>\r\n  <Example: void test(int)>, <Cat: void play()>\r\n  <Example: void morePlay(Cat)>, <Cat: void play()>\r\n  <Animal: Animal playWith(Animal)>, <Cat: void play()>\r\n  <Example: void main(java.lang.String[])>, <Cat: void play()>\r\n  <Example: void test(int)>, <Dog: void play()>\r\n  <Example: void main(java.lang.String[])>, <Dog: void play()>\r\n  <Example: void test(int)>, <Animal: Animal playWith(Animal)>\r\n  <Example: void morePlay(Cat)>, <Animal: Animal playWith(Animal)>\r\n  <Example: void main(java.lang.String[])>, <Animal: Animal playWith(Animal)\r\n```\r\n\r\nThe line `Instruction:Method[?invocation] = ?fromMethod` found in the previous query uses a special form of predicate known as *functional* predicate. Those are similar to normal ones, but they act like a map. Values found between the square brackets are mapped to only on value on the right.\r\n\r\n### Doop + DaCapo Benchmarks\r\n\r\nWe frequently analyze various programs from the [DaCapo Benchmarks suite](http://www.dacapobench.org/) using a variety of advanced analyses. E.g., let's analyze the `antlr` benchmark using a *2 type-sensitive* analysis.\r\n\r\n```\r\n./doop -a 2-type-sensitive+heap -j benchmarks/dacapo-2006/antlr.jar benchmarks/dacapo-2006/antlr-deps.jar --jre 1.7 --dacapo\r\n```\r\n\r\nTowards the end of execution, Doop will report a set of metrics gathered from the analyzed program. Those metrics are computed through the use of various queries on the resulting database. Those are found under `logic/addons/statistics`.\r\n\r\n#### Query #3\r\nFor example, one metric is the computation of casts that potentially may fail. It joins input facts as well as facts computed during execution to infer casts where the related variable may point to an object that is incompatible with the type of the cast.\r\n\r\n```\r\n_Stats:Simple:PotentiallyFailingCast(?type, ?from, ?to) <-\r\n    _Stats:Simple:ReachableCast(_, ?type, ?to, ?from),\r\n    Stats:Simple:InsensVarPointsTo(?heap, ?from),\r\n    HeapAllocation:Type[?heap] = ?heaptype,\r\n    ! AssignCompatible(?type, ?heaptype).\r\n```\r\n\r\nThe use of `_` as a predicate parameter denotes that we don't care for a specific value. It represent a parameter that is not bounded.\r\n\r\nThe above query can be found isolated in [query3.logic](https://raw.githubusercontent.com/plast-lab/doop-pldi15-tutorial/master/code/examples/query3.logic).\r\n\r\n```\r\n$ bloxbatch -db last-analysis -query -file ../examples/query3.logic\r\n```\r\n\r\n#### Aggregate Functions\r\n\r\nDatalog supports the use of aggregate functions. One such function is *count*. E.g., if we would like to compute the total number of VarPointsTo entries we would use the following.\r\n\r\n```\r\n$ bloxbatch -db last-analysis -query \\\r\n'_[] = ?n <- agg<<?n = count()>> VarPointsTo(_, _, _, _).'\r\n  4569312\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}
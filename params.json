{"name":"Doop Framework 101","tagline":"Tutorial site for PLDI 2015","body":"### About\r\n[Doop](http://doop.program-analysis.org/) is a **declarative** framework for Static Pointer Analysis of Java programs. It provides a huge variety of analyses and also the surrounding scaffolding to run an analysis end-to-end (fact generation, processing, statistics etc).\r\n\r\nThe declarative nature of Doop stems form the fact that is uses **Datalog** (more specifically *LogiQL*, a Datalog dialog developped by [LogicBlox](http://www.logicblox.com/)) to specify an analysis.\r\n\r\nThe building blocks come in the form of **predicates**. Our facts (a.k.a *EDB* logic) are represented as such. E.g. `Person(\"John\")` or `Parent(\"John\", \"Johnny jr\")`.\r\n\r\nThen we have **rules** (a.k.a *IDB* logic) to infer new information from things already known to be true. This continues until no new information can be extracted. E.g.\r\n```\r\nAncestor(x, y) <- Parent(x, y).\r\n```\r\n\r\n### Setup\r\n```\r\n$ cd tutorial_root_folder\r\n$ source environment.sh\r\n```\r\n\r\n### Toy Example\r\nWe want to compute the ancestors for a set of people. Our rules (left-arrow notation) along with their type declarations (right-arrow notation) are in [ancestors.logic](https://raw.githubusercontent.com/plast-lab/doop-pldi15-tutorial/gh-pages/examples/ancestors/ancestors.logic). Our facts (a.k.a delta logic) are in [facts.logic](https://raw.githubusercontent.com/plast-lab/doop-pldi15-tutorial/gh-pages/examples/ancestors/facts.logic). The `+` operator in front of the delta predicates, denotes that we want to add facts to our database (we could also remove or update facts).\r\n\r\nWe invoke actions on our Datalog engine using `bloxbatch`.\r\n\r\n```\r\n$ bloxbatch -db DB -create -overwrite              # create our database\r\n$ bloxbatch -db DB -addBlock -file ancestor.logic  # load our rules\r\n$ bloxbatch -db DB -execute -file facts.logic      # load our facts\r\n$ bloxbatch -db DB -print ancestor                 # print computed results\r\npredicate: Ancestor(Person, Person)\r\n...\r\n/--- start of Ancestor facts ---\\\r\n  [1]john, [0]harry\r\n  [2]dave, [0]harry\r\n  [2]dave, [1]john\r\n\\---- end of Ancestor facts ----/\r\n```\r\n\r\nThe line `Person(x), Name(x:n) -> string(n).` states that a person (represented by an internal ID) can be constructed by providing a string in the `Name` predicate. This is known as *refmode*. This is also shown in the print output. For example, `[1]john` means that the string *\"john\"* is used to create a Person with the ID *1*.\r\n\r\n### Doop Examples\r\nNow, let's focus on more meaningful examples using Doop directly. Our running example code is found in [Example.java](https://raw.githubusercontent.com/plast-lab/doop-pldi15-tutorial/gh-pages/examples/Example.java).\r\n\r\n```\r\n$ cd doop\r\n$ mkjar Example.java   # create Example.jar\r\n```\r\n\r\nWe will run a simple naive analysis (`-a naive` option) on the generated jar file (`-j Example.jar` option). This analysis has only a few basic rules but it's great for our example. Since, Doop performs a **whole program analysis**, the library will be analyzed along with application code. With the option `--jre 1.7` we specify the desired version of the library. Finally, the option `--no-stats` is to simplify execution. Doop will only analyze the given program. Afterwards, we will gather our own statistics issuing queries directly to the database.\r\n\r\n```\r\n./doop -a naive -j Example.jar --jre 1.7 --no-stats\r\n```\r\n\r\nFacts are auto-generated by the framework (using [Soot](https://github.com/Sable/soot)) and the schema can be found\r\n* in `logic/facts/declarations.logic`\r\n* and in `logic/facts/flow-insensitivity-declarations.logic`.\r\n\r\nThe rules for our naive analysis can be found in `logic/analyses/naive/analysis.logic`.\r\n\r\nFor example, the following rule states that **when** we have a heap allocation of a `?heap` object that is assigned to variable `?var` inside a method deemed reachable by our analysis, **then** we can infer that this variable may point to this heap object.\r\n```\r\nVarPointsTo(?var, ?heap) <-\r\n  AssignHeapAllocation(?heap, ?var, ?inMethod),\r\n  Reachable(?inMethod).\r\n```\r\n\r\nFurthermore, **when** we have some kind of assignment (direct or indirect) from one variable to another, and we know that the source variable may point to some heap object, **then** the target variable may point to the same heap object.\r\n```\r\nVarPointsTo(?to, ?heap) <-\r\n  Assign(?to, ?from),\r\n  VarPointsTo(?from, ?heap).\r\n```\r\nNote here that this rule is **recursive**; previously known entries about the *VarPointTo* relation may lead to the inference of additional entries. One could argue that the power of Doop lies in the ability to define **mutual recursive** rules.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}
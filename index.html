<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Doop Framework 101 : Tutorial site for PLDI 2015">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Doop Framework 101</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/plast-lab/doop-pldi15-tutorial">View on GitHub</a>

          <h1 id="project_title">Doop Framework 101</h1>
          <h2 id="project_tagline">Tutorial site for PLDI 2015</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/plast-lab/doop-pldi15-tutorial/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/plast-lab/doop-pldi15-tutorial/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="about" class="anchor" href="#about" aria-hidden="true"><span class="octicon octicon-link"></span></a>About</h3>

<p><a href="http://doop.program-analysis.org/">Doop</a> is a <strong>declarative</strong> framework for Static Pointer Analysis of Java programs. It provides a huge variety of analyses and also the surrounding scaffolding to run an analysis end-to-end (fact generation, processing, statistics etc).</p>

<p>The declarative nature of Doop stems form the fact that is uses <strong>Datalog</strong> (more specifically <em>LogiQL</em>, a Datalog dialog developped by <a href="http://www.logicblox.com/">LogicBlox</a>) to specify an analysis.</p>

<p>The building blocks come in the form of <strong>predicates</strong>. Our facts (a.k.a <em>EDB</em> logic) are represented as such. E.g. <code>Person("John")</code> or <code>Parent("John", "Johnny jr")</code>.</p>

<p>Then we have <strong>rules</strong> (a.k.a <em>IDB</em> logic) to infer new information from things already known to be true. This continues until no new information can be extracted. E.g.</p>

<pre><code>Ancestor(x, y) &lt;- Parent(x, y).
</code></pre>

<h3>
<a id="setup" class="anchor" href="#setup" aria-hidden="true"><span class="octicon octicon-link"></span></a>Setup</h3>

<pre><code>$ cd tutorial_root_folder
$ source environment.sh
</code></pre>

<h3>
<a id="toy-example" class="anchor" href="#toy-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Toy Example</h3>

<p>We want to compute the ancestors for a set of people. Our rules (left-arrow notation) along with their type declarations (right-arrow notation) are in <a href="https://raw.githubusercontent.com/plast-lab/doop-pldi15-tutorial/gh-pages/examples/ancestors/ancestors.logic">ancestors.logic</a>. Our facts (a.k.a delta logic) are in <a href="https://raw.githubusercontent.com/plast-lab/doop-pldi15-tutorial/gh-pages/examples/ancestors/facts.logic">facts.logic</a>. The <code>+</code> operator in front of the delta predicates, denotes that we want to add facts to our database (we could also remove or update facts).</p>

<p>We invoke actions on our Datalog engine using <code>bloxbatch</code>.</p>

<pre><code>$ bloxbatch -db DB -create -overwrite              # create our database
$ bloxbatch -db DB -addBlock -file ancestor.logic  # load our rules
$ bloxbatch -db DB -execute -file facts.logic      # load our facts
$ bloxbatch -db DB -print ancestor                 # print computed results
predicate: Ancestor(Person, Person)
...
/--- start of Ancestor facts ---\
  [1]john, [0]harry
  [2]dave, [0]harry
  [2]dave, [1]john
\---- end of Ancestor facts ----/
</code></pre>

<p>The line <code>Person(x), Name(x:n) -&gt; string(n).</code> states that a person (represented by an internal ID) can be constructed by providing a string in the <code>Name</code> predicate. This is known as <em>refmode</em>. This is also shown in the print output. For example, <code>[1]john</code> means that the string <em>"john"</em> is used to create a Person with the ID <em>1</em>.</p>

<h3>
<a id="doop-examples" class="anchor" href="#doop-examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Doop Examples</h3>

<p>Now, let's focus on more meaningful examples using Doop directly. Our running example code is found in <a href="https://raw.githubusercontent.com/plast-lab/doop-pldi15-tutorial/gh-pages/examples/Example.java">Example.java</a>.</p>

<pre><code>$ cd doop
$ mkjar Example.java   # create Example.jar
</code></pre>

<p>We will run a simple naive analysis (<code>-a naive</code> option) on the generated jar file (<code>-j Example.jar</code> option). This analysis has only a few basic rules but it's great for our example. Since, Doop performs a <strong>whole program analysis</strong>, the library will be analyzed along with application code. With the option <code>--jre 1.7</code> we specify the desired version of the library. Finally, the option <code>--no-stats</code> is to simplify execution. Doop will only analyze the given program. Afterwards, we will gather our own statistics issuing queries directly to the database.</p>

<pre><code>./doop -a naive -j Example.jar --jre 1.7 --no-stats
</code></pre>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Doop Framework 101 maintained by <a href="https://github.com/plast-lab">plast-lab</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
